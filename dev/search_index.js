var documenterSearchIndex = {"docs":
[{"location":"collision_operator/#Collision-Operator","page":"Collision Operator","title":"Collision Operator","text":"","category":"section"},{"location":"collision_operator/","page":"Collision Operator","title":"Collision Operator","text":"In Ludwig.jl, scattering rates are taken to be given by Fermi's golden rule, with an antisymmetrized interaction vertex:","category":"page"},{"location":"collision_operator/","page":"Collision Operator","title":"Collision Operator","text":"    Gamma(mathbfk_1 mathbfk_2 mathbfk_3 mathbfk_4) = frac12 W^2(mathbfk_1 mathbfk_2 mathbfk_3 mathbfk_4) frac2pihbardelta(varepsilon(mathbfk_1) + varepsilon(mathbfk_2) - varepsilon(mathbfk_3) - varepsilon(mathbfk_4))","category":"page"},{"location":"collision_operator/","page":"Collision Operator","title":"Collision Operator","text":"where ","category":"page"},{"location":"collision_operator/","page":"Collision Operator","title":"Collision Operator","text":"    W^2(mathbfk_1 mathbfk_2 mathbfk_3 mathbfk_4) =  langle mathbfk_1 mathbfk_2  hatW mathbfk_3 mathbfk_4 rangle  - langle mathbfk_1 mathbfk_2  hatW mathbfk_4 mathbfk_3 rangle ^2","category":"page"},{"location":"collision_operator/","page":"Collision Operator","title":"Collision Operator","text":"In the above we have ignored spin degrees of freedom. In Ludwig.jl we assume the following constraints:","category":"page"},{"location":"collision_operator/","page":"Collision Operator","title":"Collision Operator","text":"The equilibrium distribution is not spin-polarized\nOnly the spin-summed fermion population is relevant","category":"page"},{"location":"collision_operator/","page":"Collision Operator","title":"Collision Operator","text":"Under these constraints the we can write down an effective, spin-summed, antisymmetrized scattering vertex","category":"page"},{"location":"collision_operator/","page":"Collision Operator","title":"Collision Operator","text":"    W_texteff^2(mathbfk_1 mathbfk_2 mathbfk_3 mathbfk_4) = W_uparrowuparrowuparrowuparrow^2(mathbfk_1 mathbfk_2 mathbfk_3 mathbfk_4) + 2 W_uparrowdownarrowdownarrowuparrow^2(mathbfk_1 mathbfk_2 mathbfk_3 mathbfk_4)","category":"page"},{"location":"collision_operator/","page":"Collision Operator","title":"Collision Operator","text":"To allow for flexibility in scattering models, a user-defined effective scattering vertex of the form Weff_squared(p1::AbstractPatch, p2::AbstractPatch, p3::AbstractPatch, p4::AbstractPatch; kwargs...) must be supplied. For a vertex depending only on the band index and momentum differences between patches, all required information is already contained in the fields of each AbstractPatch, making the calculation efficient. If the scattering vertex depends on some function value defined on the patches (for example the orbital mixing character at the sampled point), passing an array of values calulated ahead of time via a keyword argument prevents needed to repeatedly evaluate a costly function each time the vertex function is invoked. All keyword arguments passed to electron_electron will be bypassed to the user's Weff_squared function.","category":"page"},{"location":"collision_operator/","page":"Collision Operator","title":"Collision Operator","text":"The linearized collision integral is given by","category":"page"},{"location":"collision_operator/","page":"Collision Operator","title":"Collision Operator","text":"beginaligned\nmathbfL_ij = frac1d A_i frac2pi  hbar1 - f^(0)_i \nfrac1(2pi)^6   frac12 sum_m  left( W^2_eff(p_ip_jp_mp_i+j-m)  f^(0)_j (1 - f^(0)_m) mathcalK_ijmright\nleft- ( W^2_eff(p_ip_mp_jp_i+m-j) + W^2_eff(p_ip_mp_i+m-jp_j) ) f^(0)_m(1 - f^(0)_j) mathcalK_imj right)\nendaligned","category":"page"},{"location":"collision_operator/","page":"Collision Operator","title":"Collision Operator","text":"where","category":"page"},{"location":"collision_operator/","page":"Collision Operator","title":"Collision Operator","text":"    mathcalK_ijm = int_i d^2 mathbfk_i int_j d^2 mathbfk_j int_m d^2 mathbfk_m (1 - f^(0)(mathbfk_i + mathbfk_j - mathbfk_m)) delta(varepsilon_i + varepsilon_j - varepsilon_m - varepsilon(mathbfk_i + mathbfk_j - mathbfk_m))","category":"page"},{"location":"collision_operator/","page":"Collision Operator","title":"Collision Operator","text":"Ludwig.electron_electron(grid::Vector{Patch}, f0s::Vector{Float64}, i::Int, j::Int, bands, T::Real, Weff_squared, rlv, bz; umklapp = true, kwargs...)","category":"page"},{"location":"collision_operator/#Ludwig.Integration.electron_electron-Tuple{Vector{Patch}, Vector{Float64}, Int64, Int64, Any, Real, Any, Any, Any}","page":"Collision Operator","title":"Ludwig.Integration.electron_electron","text":"electron_electron(grid::Vector{Patch}, f0s::Vector{Float64}, i::Int, j::Int, bands, T::Real, Weff_squared, rlv, bz; umklapp = true, kwargs...)\n\nCompute the element (i,j) of the linearized Boltzmann collision operator for electron electron scattering.\n\nThe bands used to construct grid are callable using the interpolated dispersions in itps. The vector f0s stores the value of the Fermi-Dirac distribution at each patch center and can be calculated independent of i and j. The functions Fpp and Fpk are vertex factors defined for two Patch variables and for one Patch and one momentum vector respectively, using the orbital weight vectors defined weights evaluated at the patch centers of grid. \n\n\n\n\n\n","category":"method"},{"location":"mesh/marching_squares/#Marching-Squares-Algorithm","page":"Marching Squares","title":"Marching Squares Algorithm","text":"","category":"section"},{"location":"mesh/marching_squares/","page":"Marching Squares","title":"Marching Squares","text":"Ludwig generates the energy contours for its Fermi-surface centered meshes using a simple marching squares algorithm.  This implementation is inspired by Contour.jl, but has been modified to generate contours bounded by a convex polygon. This is useful for generating the contours only within the (irreducible) Brillouin zone to create meshes that fully preserve the symmetry of the lattice.","category":"page"},{"location":"mesh/marching_squares/","page":"Marching Squares","title":"Marching Squares","text":"Resulting contours are returned in the convenient Isoline Bundle which stores information about the size and topology of the Fermi surface. ","category":"page"},{"location":"mesh/marching_squares/","page":"Marching Squares","title":"Marching Squares","text":"Ludwig.Isoline","category":"page"},{"location":"mesh/marching_squares/#Ludwig.MarchingSquares.Isoline","page":"Marching Squares","title":"Ludwig.MarchingSquares.Isoline","text":"Representation of a contour as an ordered set of discrete points\n\nFields\n\npoints: Vector of points in contour\nisclosed: Boolean which is true if the contour returned to the starting point when being generated\narclength: Length of the contour\n\n\n\n\n\n","category":"type"},{"location":"mesh/marching_squares/","page":"Marching Squares","title":"Marching Squares","text":"Ludwig.IsolineBundle","category":"page"},{"location":"mesh/marching_squares/#Ludwig.MarchingSquares.IsolineBundle","page":"Marching Squares","title":"Ludwig.MarchingSquares.IsolineBundle","text":"Collection of contours generated from a matrix.\n\nFields\n\nisolines: Vector of Isolines\nlevel: Constant value along contours in isolines\n\n\n\n\n\n","category":"type"},{"location":"mesh/mesh/#Fermi-Surface-Centered-Meshes","page":"Overview","title":"Fermi Surface Centered Meshes","text":"","category":"section"},{"location":"mesh/mesh/","page":"Overview","title":"Overview","text":"At finite temperature, the particles participating in scattering with non-negligible weight belong to a narrow annulus of energies near the Fermi surface. Thus, for calculating the Boltzmann collision matrix, the sampled momenta are chosen to be uniformly distributed in arclength along energy contours and energy above and below the Fermi surface. This follows the approach outlined in J. M. Buhmann's PhD Thesis.","category":"page"},{"location":"mesh/mesh/","page":"Overview","title":"Overview","text":"The sampled momenta lie at the local energy-arclength coordinate center of each Patch, and information about the patch used in integration is stored in the fields of a variable of type Patch.","category":"page"},{"location":"mesh/mesh/","page":"Overview","title":"Overview","text":"Ludwig.FSMesh.Patch","category":"page"},{"location":"mesh/mesh/#Ludwig.FSMesh.Patch","page":"Overview","title":"Ludwig.FSMesh.Patch","text":"Patch(e::Float64, k::SVector{2,Float64}, v::SVector{2,Float64}, de::Float64, dV::Float64, jinv::Matrix{Float64}, djinv::Float64, band_index::Int)\n\nConstruct a `Patch' object defining regions of momentum space over which to integrate. \n\nFields\n\ne: energy\nk: momentum \nv: group velocity\nde: width of patch in energy\ndV: area of patch in momentum space\njinv: Jacobian of transformation from (kx, ky) –> (E, s)\ndjinv: determinant of above Jacobian\nband_index: index of band from which e was sampled at k\n\n\n\n\n\n","category":"type"},{"location":"mesh/mesh/","page":"Overview","title":"Overview","text":"Patches within a mesh are generated by creating a contour at a sample energy varepsilon and two additional contours at pmDeltavarepsilon. The central contour is cut into segments of equal arclength, and the intersection of the gradient of energy at each cut with the boundary contours at pmDeltavarepsilon define the corners of the patch. Taking the representative momentum to lie halfway along the central contour between two cuts means we have a patch which when mapped to local energy-arclength coordinates is rectangular with area Delta varepsilon Delta s and the representative momentum of the patch at the origin. This scheme is ideal for integration. ","category":"page"},{"location":"mesh/mesh/","page":"Overview","title":"Overview","text":"These patches are stored in a container type Mesh which contains additional fields for plotting.","category":"page"},{"location":"mesh/mesh/","page":"Overview","title":"Overview","text":"Ludwig.FSMesh.Mesh","category":"page"},{"location":"mesh/mesh/#Ludwig.FSMesh.Mesh","page":"Overview","title":"Ludwig.FSMesh.Mesh","text":"Mesh(patches::Vector{Patch}, corners::Vector{SVector{2,Float64}}, corner_inds::Vector{SVector{4,Int}}})\n\nConstruct a container struct of patches which contains information for plotting functions defined on patch centers.\n\nFields\n\npatches: Vector of patches\ncorners: Vector of points on patch corners for plotting mesh\ncorner_inds: Vector of vector of indices in the corners vector corresponding to the corners of each patch in patches\n\n\n\n\n\n","category":"type"},{"location":"mesh/mesh/#References","page":"Overview","title":"References","text":"","category":"section"},{"location":"mesh/mesh/","page":"Overview","title":"Overview","text":"J. M. Buhmann, Unconventional Transport Properties of Correlated Two-Dimensional Fermi Liquids, Ph.D. thesis, Institute for Theoretical Physics ETH Zurich (2013).","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Ludwig.jl is a registered package on the general Julia package registry. From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> add Ludwig","category":"page"},{"location":"#Ludwig.jl-Documentation","page":"Home","title":"Ludwig.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ludwig provides a framework for generating the linearized Boltzmann collision operator for electron-electron scattering in two-dimensional materials and materials with a quasi-2D band structure. This package also provides utilities for calculating transport properties such as conductivity and viscosity from the generated collision matrix.","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Unicode\nThis package uses Unicode characters (primarily Greek letters) such as η, σ, and ε in both function names and for function arguments.  Unicode symbols can be entered in the Julia REPL by typing, e.g., \\eta followed by tab key. Read more about Unicode  symbols in the Julia Documentation.","category":"page"},{"location":"#Units","page":"Home","title":"Units","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For all calculations, hbar = k_B = 1 For converting output back to physical units, Ludwig includes the values of some important physical constants from the 2022 CODATA Recommended Values of the Fundamental Physical Constants.","category":"page"},{"location":"","page":"Home","title":"Home","text":"G0","category":"page"},{"location":"#Ludwig.G0","page":"Home","title":"Ludwig.G0","text":"Conductance quantum in Siemens\n\n\n\n\n\n","category":"constant"},{"location":"","page":"Home","title":"Home","text":"kb","category":"page"},{"location":"#Ludwig.kb","page":"Home","title":"Ludwig.kb","text":"Boltzmann constant in eV/K\n\n\n\n\n\n","category":"constant"},{"location":"","page":"Home","title":"Home","text":"hbar","category":"page"},{"location":"#Ludwig.hbar","page":"Home","title":"Ludwig.hbar","text":"Reduced Planck's constant in eV.s\n\n\n\n\n\n","category":"constant"},{"location":"","page":"Home","title":"Home","text":"e_charge","category":"page"},{"location":"#Ludwig.e_charge","page":"Home","title":"Ludwig.e_charge","text":"Electron charge in C\n\n\n\n\n\n","category":"constant"},{"location":"","page":"Home","title":"Home","text":"danger: Energy Scale\nSince we take k_B = 1, temperatures must be expressed in the same energy scale used by the Hamiltonian.  We recommend expressing all energies in units of eV for simplicity in multiband calculations where each band may have an independent natural energy scale. This is particularly important since many function involve the ratio of the energy to temperature; e.g. f0(E, T)","category":"page"},{"location":"","page":"Home","title":"Home","text":"f0","category":"page"},{"location":"#Ludwig.f0","page":"Home","title":"Ludwig.f0","text":"    f0(E, T)\n\nReturn the value of the Fermi-Dirac distribution for energy E and temperature T.\n\n    f^(0)(varepsilon) = frac11 + e^varepsilonk_B T\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"Moreover, all momentum integrals are normalized by the volume of the Brillouin zone. This simplifies calculations, but again requires appropriate dimension to be restored later:","category":"page"},{"location":"","page":"Home","title":"Home","text":"int fracd^2mathbfk(2pi)^2 to frac1v_textcell int d^2mathbfk","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"properties/inner_product/#Inner-Product","page":"Inner Product","title":"Inner Product","text":"","category":"section"},{"location":"properties/inner_product/","page":"Inner Product","title":"Inner Product","text":"The linearized Boltzmann collision operator computed by electron_electron() is not Hermitian. However, we can define the auxiliary matrix","category":"page"},{"location":"properties/inner_product/","page":"Inner Product","title":"Inner Product","text":"    L^text(s)_ij = f^(0)_i (1 - f^(0)_i) fracdV_i mathbfL_ij","category":"page"},{"location":"properties/inner_product/","page":"Inner Product","title":"Inner Product","text":"which is symmetric. By defining the inner product as","category":"page"},{"location":"properties/inner_product/","page":"Inner Product","title":"Inner Product","text":"    langle a  b rangle equiv frac1Vsum_mathbfk f^(0)(epsilon_mathbfk) (1 - f^(0)(epsilon_mathbfk)) a^_k b_k","category":"page"},{"location":"properties/inner_product/","page":"Inner Product","title":"Inner Product","text":"then the matrix computed by electron_electron() is Hermitian with respect to the above inner product.","category":"page"},{"location":"properties/inner_product/","page":"Inner Product","title":"Inner Product","text":"@docs Ludwig.inner_product","category":"page"}]
}
